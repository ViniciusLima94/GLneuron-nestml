/* generated by template org.nest.nestml.neuron.NeuronClass*/
/*
*  gl_neuron.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "gl_neuron.h"

/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<gl_neuron> gl_neuron::recordablesMap_;

namespace nest {
// Override the create() method with one call to RecordablesMap::insert_()
// for each quantity to be recorded.
template <> void RecordablesMap<gl_neuron>::create() {
  // use standard names whereever you can for consistency!
  /* generated by template org.nest.nestml.function.RecordCallback*/

  insert_("V_m", &gl_neuron::get_V_m);

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the V_r with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the V_t with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the V_s with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the tau_m with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the r with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the gamma with the domain type double

  /* generated by template org.nest.nestml.function.RecordCallback*/

  // ignores the delta with the domain type double
}
}

/* ----------------------------------------------------------------
* Default constructors defining default parameters and state
* ---------------------------------------------------------------- */

gl_neuron::Parameters_::Parameters_() {}

gl_neuron::State_::State_() {}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

void gl_neuron::Parameters_::set(const DictionaryDatum &__d) {}

void gl_neuron::State_::set(const DictionaryDatum &__d, const Parameters_ &p) {}

gl_neuron::Buffers_::Buffers_(gl_neuron &n) : logger_(n), s_(0), c_(0), e_(0) {}

gl_neuron::Buffers_::Buffers_(const Buffers_ &, gl_neuron &n)
    : logger_(n), s_(0), c_(0), e_(0) {}

/* ----------------------------------------------------------------
* Default and copy constructor for node
* ---------------------------------------------------------------- */
// TODO inner components
gl_neuron::gl_neuron() : Archiving_Node(), P_(), S_(), B_(*this) {
  recordablesMap_.create();

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.V_r = ((-65.0));

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.V_t = ((-64.5));

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.V_s = ((-37.5));

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.tau_m = 10;

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.r = 1.0;

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.gamma = pow((0.037), (((-1))));

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  P_.delta = 0.0;

  /* generated by template org.nest.nestml.function.MemberInitialization*/

  S_.y[State_::V_m] = get_V_r();
}

gl_neuron::gl_neuron(const gl_neuron &n)
    : Archiving_Node(), P_(n.P_), S_(n.S_), B_(n.B_, *this) {}

/* ----------------------------------------------------------------
* Destructors
* ---------------------------------------------------------------- */

gl_neuron::~gl_neuron() {
  // GSL structs may not have been allocated, so we need to protect destruction
  if (B_.s_)
    gsl_odeiv_step_free(B_.s_);
  if (B_.c_)
    gsl_odeiv_control_free(B_.c_);
  if (B_.e_)
    gsl_odeiv_evolve_free(B_.e_);
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void gl_neuron::init_state_(const Node &proto) { // TODO inner components

  const gl_neuron &pr = downcast<gl_neuron>(proto);
  S_ = pr.S_;
}

/* generated by template org.nest.nestml.function.GSLDifferentiationFunction*/
extern "C" inline int gl_neuron_dynamics(double, const double y[], double f[],
                                         void *pnode) {
  typedef gl_neuron::State_ State_;
  // get access to node so we can almost work as in a member function
  assert(pnode);
  const gl_neuron &node = *(reinterpret_cast<gl_neuron *>(pnode));

  // y[] here is---and must be---the state vector supplied by the integrator,
  // not the state vector in the node, node.S_.y[].

  f[State_::V_m] = (((-y[State_::V_m])) + node.get_V_r()) / node.get_tau_m() +
                   node.B_.I_inj_last_value_ + node.B_.I_syn_last_value_;

  return GSL_SUCCESS;
}

void gl_neuron::init_buffers_() {
  get_I_inj().clear(); // includes resize
  get_I_syn().clear(); // includes resize
  B_.logger_.reset();  // includes resize
  Archiving_Node::clear_history();
  if (B_.s_ == 0)
    B_.s_ = gsl_odeiv_step_alloc(gsl_odeiv_step_rkf45, 1);
  else
    gsl_odeiv_step_reset(B_.s_);

  if (B_.c_ == 0) {
    B_.c_ = gsl_odeiv_control_y_new(1e-6, 0.0);
  } else {
    gsl_odeiv_control_init(B_.c_, 1e-6, 0.0, 1.0, 0.0);
  }

  if (B_.e_ == 0) {
    B_.e_ = gsl_odeiv_evolve_alloc(1);
  } else {
    gsl_odeiv_evolve_reset(B_.e_);
  }

  B_.sys_.function = gl_neuron_dynamics;
  B_.sys_.jacobian = NULL;
  B_.sys_.dimension = 1;
  B_.sys_.params = reinterpret_cast<void *>(this);
}

void gl_neuron::calibrate() { B_.logger_.init(); }

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*

 */
void gl_neuron::update(nest::Time const &origin, const long from,
                       const long to) {

  double step_ = nest::Time::get_resolution().get_ms();
  double IntegrationStep_ = nest::Time::get_resolution().get_ms();
  double t = 0;

  for (long lag = from; lag < to; ++lag) {
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.I_inj_last_value_ = get_I_inj().get_value(lag);
    // TODO this case must be handled uniformly, also NESTReferenceConverter
    // must be adopted
    B_.I_syn_last_value_ = get_I_syn().get_value(lag);

    /* generated by template org.nest.spl.Block*/
    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.FunctionCall*/
    /* generated by template org.nest.spl.GSLIntegrator*/
    t = 0;

    while (t < step_) {
      const int status =
          gsl_odeiv_evolve_apply(B_.e_, B_.c_, B_.s_,
                                 &B_.sys_,          // system of ODE
                                 &t,                // from t
                                 step_,             // to t <= step
                                 &IntegrationStep_, // integration step size
                                 S_.y);             // neuronal state

      if (status != GSL_SUCCESS) {
        throw nest::GSLSolverFailure(get_name(), status);
      }
    }

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.SmallStatement*/
    /* generated by template org.nest.spl.Declaration*/

    double rnd_number = random();

    /* generated by template org.nest.spl.Statement*/
    //
    /* generated by template org.nest.spl.CompoundStatement*/
    /* generated by template org.nest.spl.IfStatement*/

    if (((((((S_.y[State_::V_m] > P_.V_t)) &&
            ((S_.y[State_::V_m] <= P_.V_s)))) &&
          ((rnd_number <
            (std::pow(P_.gamma * (S_.y[State_::V_m] - P_.V_t), P_.r) +
             P_.delta))))) ||
        ((S_.y[State_::V_m] > P_.V_s))) {
      /* generated by template org.nest.spl.Block*/
      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.FunctionCall*/
      set_spiketime(nest::Time::step(origin.get_steps() + lag + 1));
      nest::SpikeEvent se;
      nest::kernel().event_delivery_manager.send(*this, se, lag);
      ;

      /* generated by template org.nest.spl.Statement*/
      //
      /* generated by template org.nest.spl.SmallStatement*/
      /* generated by template org.nest.spl.Assignment*/
      S_.y[State_::V_m] = P_.V_r;

    } /* if end */

    // voltage logging
    B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void gl_neuron::handle(nest::DataLoggingRequest &e) { B_.logger_.handle(e); }

void gl_neuron::handle(nest::SpikeEvent &e) {
  assert(e.get_delay() > 0);

  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
  /* generated by template org.nest.nestml.buffer.SpikeBufferFill*/

  if (weight >= 0.0) // excitatory
  {
    get_I_syn().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),
        weight * multiplicity);
  }
  if (weight < 0.0) // inhibitory
  {
    get_I_syn().add_value(
        e.get_rel_delivery_steps(
            nest::kernel().simulation_manager.get_slice_origin()),

        weight * multiplicity);
  }
}

void gl_neuron::handle(nest::CurrentEvent &e) {
  assert(e.get_delay() > 0);

  const double current = e.get_current();
  const double weight = e.get_weight();

  // add weighted current; HEP 2002-10-04
  get_I_inj().add_value(
      e.get_rel_delivery_steps(
          nest::kernel().simulation_manager.get_slice_origin()),
      weight * current);
}
